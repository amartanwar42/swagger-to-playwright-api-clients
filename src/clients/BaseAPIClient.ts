/**
 * BaseAPIClient - Base class for making API requests using Playwright's APIRequestContext
 * Generated by swagger-to-playwright-api-clients
 */

import { request, APIRequestContext } from '@playwright/test';
import type { Logger } from 'winston';

/**
 * Supported query parameter value types
 */
export type QueryParamValue = string | number | boolean | undefined | (string | number | boolean)[];

/**
 * Options for individual API requests
 */
export interface RequestOptions {
	headers?: Record<string, string>;
	params?: Record<string, QueryParamValue>;
	timeout?: number;
}

/**
 * Standard API response result
 */
export interface APIResponseResult<T = unknown> {
	body: T;
	status: number;
	headers: Record<string, string>;
}

/**
 * BaseAPIClient - Provides HTTP methods using Playwright's request API
 *
 * @example
 * import { getLogger } from 'swagger-to-playwright-api-clients';
 * const client = new BaseAPIClient('https://api.example.com', {}, getLogger());
 */
export class BaseAPIClient {
	private baseURL: string;
	private defaultHeaders: Record<string, string>;
	private context: APIRequestContext | null = null;
	private logger?: Logger;

	constructor(baseURL: string, defaultHeaders: Record<string, string> = {}, logger?: Logger) {
		this.baseURL = baseURL;
		this.defaultHeaders = defaultHeaders;
		this.logger = logger;
	}

	/**
	 * Initialize the API request context
	 */
	async init(): Promise<void> {
		this.context = await request.newContext({
			baseURL: this.baseURL,
			extraHTTPHeaders: this.defaultHeaders,
		});
		this.logger?.info(`BaseAPIClient initialized with baseURL: ${this.baseURL}`);
	}

	/**
	 * Dispose the API request context
	 */
	async dispose(): Promise<void> {
		if (this.context) {
			await this.context.dispose();
			this.context = null;
			this.logger?.info('BaseAPIClient disposed');
		}
	}

	/**
	 * Get the request context, initializing if needed
	 */
	private async getContext(): Promise<APIRequestContext> {
		if (!this.context) {
			await this.init();
		}
		return this.context!;
	}

	/**
	 * Build URL with query parameters
	 */
	private buildUrl(endpoint: string, params?: Record<string, QueryParamValue>): string {
		if (!params) return endpoint;

		const searchParams = new URLSearchParams();
		for (const [key, value] of Object.entries(params)) {
			if (value !== undefined) {
				if (Array.isArray(value)) {
					for (const item of value) {
						searchParams.append(key, String(item));
					}
				} else {
					searchParams.append(key, String(value));
				}
			}
		}

		const queryString = searchParams.toString();
		if (!queryString) return endpoint;

		return `${endpoint}${endpoint.includes('?') ? '&' : '?'}${queryString}`;
	}

	/**
	 * Log request details
	 */
	private logRequest(
		method: string,
		url: string,
		headers?: Record<string, string>,
		body?: unknown
	): void {
		this.logger?.info(`>>> ${method} ${this.baseURL}${url}`);
		const allHeaders = { ...this.defaultHeaders, ...headers };
		this.logger?.debug(`Headers: ${JSON.stringify(allHeaders, null, 2)}`);
		if (body !== undefined) {
			this.logger?.info(`Body: ${JSON.stringify(body, null, 2)}`);
		}
	}

	/**
	 * Log response details
	 */
	private logResponse<T>(method: string, url: string, status: number, body: T): void {
		this.logger?.info(`<<< ${method} ${this.baseURL}${url} - Status: ${status}`);
		this.logger?.info(`Response: ${JSON.stringify(body, null, 2)}`);
	}

	/**
	 * Parse response into standard result format
	 */
	private async parseResponse<T>(
		response: Awaited<ReturnType<APIRequestContext['get']>>
	): Promise<APIResponseResult<T>> {
		let body: T;
		const contentType = response.headers()['content-type'] || '';

		if (contentType.includes('application/json')) {
			try {
				body = await response.json();
			} catch {
				body = (await response.text()) as unknown as T;
			}
		} else {
			body = (await response.text()) as unknown as T;
		}

		return {
			body,
			status: response.status(),
			headers: response.headers(),
		};
	}

	/**
	 * GET request
	 */
	async get<T = unknown>(
		endpoint: string,
		options?: RequestOptions
	): Promise<APIResponseResult<T>> {
		const ctx = await this.getContext();
		const url = this.buildUrl(endpoint, options?.params);

		this.logRequest('GET', url, options?.headers);

		const response = await ctx.get(url, {
			headers: options?.headers,
			timeout: options?.timeout,
		});

		const result = await this.parseResponse<T>(response);
		this.logResponse('GET', url, result.status, result.body);

		return result;
	}

	/**
	 * POST request
	 */
	async post<T = unknown>(
		endpoint: string,
		data?: unknown,
		options?: RequestOptions
	): Promise<APIResponseResult<T>> {
		const ctx = await this.getContext();
		const url = this.buildUrl(endpoint, options?.params);

		this.logRequest('POST', url, options?.headers, data);

		const response = await ctx.post(url, {
			data,
			headers: options?.headers,
			timeout: options?.timeout,
		});

		const result = await this.parseResponse<T>(response);
		this.logResponse('POST', url, result.status, result.body);

		return result;
	}

	/**
	 * PUT request
	 */
	async put<T = unknown>(
		endpoint: string,
		data?: unknown,
		options?: RequestOptions
	): Promise<APIResponseResult<T>> {
		const ctx = await this.getContext();
		const url = this.buildUrl(endpoint, options?.params);

		this.logRequest('PUT', url, options?.headers, data);

		const response = await ctx.put(url, {
			data,
			headers: options?.headers,
			timeout: options?.timeout,
		});

		const result = await this.parseResponse<T>(response);
		this.logResponse('PUT', url, result.status, result.body);

		return result;
	}

	/**
	 * PATCH request
	 */
	async patch<T = unknown>(
		endpoint: string,
		data?: unknown,
		options?: RequestOptions
	): Promise<APIResponseResult<T>> {
		const ctx = await this.getContext();
		const url = this.buildUrl(endpoint, options?.params);

		this.logRequest('PATCH', url, options?.headers, data);

		const response = await ctx.patch(url, {
			data,
			headers: options?.headers,
			timeout: options?.timeout,
		});

		const result = await this.parseResponse<T>(response);
		this.logResponse('PATCH', url, result.status, result.body);

		return result;
	}

	/**
	 * DELETE request
	 */
	async delete<T = unknown>(
		endpoint: string,
		data?: unknown,
		options?: RequestOptions
	): Promise<APIResponseResult<T>> {
		const ctx = await this.getContext();
		const url = this.buildUrl(endpoint, options?.params);

		this.logRequest('DELETE', url, options?.headers, data);

		const response = await ctx.delete(url, {
			data,
			headers: options?.headers,
			timeout: options?.timeout,
		});

		const result = await this.parseResponse<T>(response);
		this.logResponse('DELETE', url, result.status, result.body);

		return result;
	}
}

export default BaseAPIClient;

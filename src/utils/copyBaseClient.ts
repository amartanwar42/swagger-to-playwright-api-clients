/**
 * Utility to copy BaseAPIClient to user's project
 */

import * as fs from 'fs';
import * as path from 'path';
import logger from './logger';

/**
 * BaseAPIClient template content - with Winston logger
 */
const BASE_API_CLIENT_CONTENT = `/**
 * BaseAPIClient - Base class for making API requests using Playwright's APIRequestContext
 * Generated by swagger-to-playwright-api-clients
 */

import { request, APIRequestContext } from '@playwright/test';
import winston from 'winston';
import * as path from 'path';
import * as fs from 'fs';

/**
 * Log level types
 */
export type LogLevel = 'error' | 'warn' | 'info' | 'debug' | 'verbose';

/**
 * Logger configuration options
 */
export interface LoggerConfig {
	/**
	 * Log level (can also be set via LOG_LEVEL environment variable)
	 * Environment variable takes precedence if set
	 * Default: 'info'
	 */
	level?: LogLevel;

	/**
	 * Output directory for log files
	 * Default: './logs' (relative to project root)
	 */
	outputDir?: string;

	/**
	 * Whether to print logs to console
	 * Can also be set via LOG_CONSOLE environment variable ('true' or 'false')
	 * Default: true
	 */
	console?: boolean;

	/**
	 * Whether to write logs to file
	 * Default: true
	 */
	file?: boolean;

	/**
	 * Maximum size of each log file in bytes
	 * Default: 5242880 (5MB)
	 */
	maxFileSize?: number;

	/**
	 * Maximum number of log files to keep
	 * Default: 5
	 */
	maxFiles?: number;
}

/**
 * Default logger configuration
 */
const defaultLoggerConfig: LoggerConfig = {
	level: 'info',
	outputDir: './logs',
	console: true,
	file: true,
	maxFileSize: 5242880,
	maxFiles: 5,
};

// Store logger instance
let loggerInstance: winston.Logger | null = null;
let currentConfig: LoggerConfig = { ...defaultLoggerConfig };

/**
 * Get log level from environment or config
 */
function getLogLevel(config: LoggerConfig): LogLevel {
	const envLevel = process.env.LOG_LEVEL as LogLevel | undefined;
	return envLevel || config.level || 'info';
}

/**
 * Check if console logging is enabled
 */
function isConsoleEnabled(config: LoggerConfig): boolean {
	const envConsole = process.env.LOG_CONSOLE;
	if (envConsole !== undefined) {
		return envConsole.toLowerCase() === 'true';
	}
	return config.console !== false;
}

/**
 * File format for logs
 */
const fileFormat = winston.format.combine(
	winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
	winston.format.errors({ stack: true }),
	winston.format.printf(({ level, message, timestamp, stack }) => {
		if (stack) {
			return \`\${timestamp} [\${level.toUpperCase()}]: \${message}\\n\${stack}\`;
		}
		return \`\${timestamp} [\${level.toUpperCase()}]: \${message}\`;
	})
);

/**
 * Console format with colors
 */
const consoleFormat = winston.format.combine(
	winston.format.colorize({ all: true }),
	winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
	winston.format.printf(({ level, message, timestamp }) => {
		return \`\${timestamp} [\${level}]: \${message}\`;
	})
);

/**
 * Create logger instance
 */
function createLogger(config: LoggerConfig = {}): winston.Logger {
	const mergedConfig: LoggerConfig = { ...defaultLoggerConfig, ...config };
	const logLevel = getLogLevel(mergedConfig);
	const consoleEnabled = isConsoleEnabled(mergedConfig);
	const logDir = path.resolve(process.cwd(), mergedConfig.outputDir || './logs');

	if (mergedConfig.file !== false) {
		if (!fs.existsSync(logDir)) {
			fs.mkdirSync(logDir, { recursive: true });
		}
	}

	const transports: winston.transport[] = [];

	if (consoleEnabled) {
		transports.push(
			new winston.transports.Console({
				format: consoleFormat,
			})
		);
	}

	if (mergedConfig.file !== false) {
		transports.push(
			new winston.transports.File({
				filename: path.join(logDir, 'combined.log'),
				maxsize: mergedConfig.maxFileSize || 5242880,
				maxFiles: mergedConfig.maxFiles || 5,
			})
		);
		transports.push(
			new winston.transports.File({
				filename: path.join(logDir, 'error.log'),
				level: 'error',
				maxsize: mergedConfig.maxFileSize || 5242880,
				maxFiles: mergedConfig.maxFiles || 5,
			})
		);
	}

	return winston.createLogger({
		level: logLevel,
		format: fileFormat,
		transports,
	});
}

/**
 * Configure the logger with given configuration
 */
export function configureLogger(config: LoggerConfig = {}): winston.Logger {
	currentConfig = { ...defaultLoggerConfig, ...config };
	loggerInstance = createLogger(currentConfig);
	return loggerInstance;
}

/**
 * Get the current logger instance
 */
export function getLogger(): winston.Logger {
	if (!loggerInstance) {
		loggerInstance = createLogger(currentConfig);
	}
	return loggerInstance;
}

/**
 * Supported query parameter value types
 */
export type QueryParamValue = string | number | boolean | undefined | (string | number | boolean)[];

/**
 * Options for individual API requests
 */
export interface RequestOptions {
	headers?: Record<string, string>;
	params?: Record<string, QueryParamValue>;
	timeout?: number;
}

/**
 * Standard API response result
 */
export interface APIResponseResult<T = unknown> {
	body: T;
	status: number;
	headers: Record<string, string>;
}

/**
 * BaseAPIClient - Provides HTTP methods using Playwright's request API
 */
export class BaseAPIClient {
	private baseURL: string;
	private defaultHeaders: Record<string, string>;
	private context: APIRequestContext | null = null;
	private logger: winston.Logger;

	constructor(
		baseURL: string,
		defaultHeaders: Record<string, string> = {},
		logger?: winston.Logger
	) {
		this.baseURL = baseURL;
		this.defaultHeaders = defaultHeaders;
		this.logger = logger || getLogger();
	}

	/**
	 * Initialize the API request context
	 */
	async init(): Promise<void> {
		this.context = await request.newContext({
			baseURL: this.baseURL,
			extraHTTPHeaders: this.defaultHeaders,
		});
		this.logger.info(\`BaseAPIClient initialized with baseURL: \${this.baseURL}\`);
	}

	/**
	 * Dispose the API request context
	 */
	async dispose(): Promise<void> {
		if (this.context) {
			await this.context.dispose();
			this.context = null;
			this.logger.info('BaseAPIClient disposed');
		}
	}

	/**
	 * Get the request context, initializing if needed
	 */
	private async getContext(): Promise<APIRequestContext> {
		if (!this.context) {
			await this.init();
		}
		return this.context!;
	}

	/**
	 * Build URL with query parameters
	 */
	private buildUrl(
		endpoint: string,
		params?: Record<string, QueryParamValue>
	): string {
		if (!params) return endpoint;

		const searchParams = new URLSearchParams();
		for (const [key, value] of Object.entries(params)) {
			if (value !== undefined) {
				if (Array.isArray(value)) {
					for (const item of value) {
						searchParams.append(key, String(item));
					}
				} else {
					searchParams.append(key, String(value));
				}
			}
		}

		const queryString = searchParams.toString();
		if (!queryString) return endpoint;

		return \`\${endpoint}\${endpoint.includes('?') ? '&' : '?'}\${queryString}\`;
	}

	/**
	 * Log request details
	 */
	private logRequest(
		method: string,
		url: string,
		headers?: Record<string, string>,
		body?: unknown
	): void {
		this.logger.info(\`>>> \${method} \${this.baseURL}\${url}\`);
		const allHeaders = { ...this.defaultHeaders, ...headers };
		this.logger.debug(\`Headers: \${JSON.stringify(allHeaders, null, 2)}\`);
		if (body !== undefined) {
			this.logger.info(\`Body: \${JSON.stringify(body, null, 2)}\`);
		}
	}

	/**
	 * Log response details
	 */
	private logResponse<T>(method: string, url: string, status: number, body: T): void {
		this.logger.info(\`<<< \${method} \${this.baseURL}\${url} - Status: \${status}\`);
		this.logger.info(\`Response: \${JSON.stringify(body, null, 2)}\`);
	}

	/**
	 * Parse response into standard result format
	 */
	private async parseResponse<T>(
		response: Awaited<ReturnType<APIRequestContext['get']>>
	): Promise<APIResponseResult<T>> {
		let body: T;
		const contentType = response.headers()['content-type'] || '';

		if (contentType.includes('application/json')) {
			try {
				body = await response.json();
			} catch {
				body = (await response.text()) as unknown as T;
			}
		} else {
			body = (await response.text()) as unknown as T;
		}

		return {
			body,
			status: response.status(),
			headers: response.headers(),
		};
	}

	/**
	 * GET request
	 */
	async get<T = unknown>(
		endpoint: string,
		options?: RequestOptions
	): Promise<APIResponseResult<T>> {
		const ctx = await this.getContext();
		const url = this.buildUrl(endpoint, options?.params);

		this.logRequest('GET', url, options?.headers);

		const response = await ctx.get(url, {
			headers: options?.headers,
			timeout: options?.timeout,
		});

		const result = await this.parseResponse<T>(response);
		this.logResponse('GET', url, result.status, result.body);

		return result;
	}

	/**
	 * POST request
	 */
	async post<T = unknown>(
		endpoint: string,
		data?: unknown,
		options?: RequestOptions
	): Promise<APIResponseResult<T>> {
		const ctx = await this.getContext();
		const url = this.buildUrl(endpoint, options?.params);

		this.logRequest('POST', url, options?.headers, data);

		const response = await ctx.post(url, {
			data,
			headers: options?.headers,
			timeout: options?.timeout,
		});

		const result = await this.parseResponse<T>(response);
		this.logResponse('POST', url, result.status, result.body);

		return result;
	}

	/**
	 * PUT request
	 */
	async put<T = unknown>(
		endpoint: string,
		data?: unknown,
		options?: RequestOptions
	): Promise<APIResponseResult<T>> {
		const ctx = await this.getContext();
		const url = this.buildUrl(endpoint, options?.params);

		this.logRequest('PUT', url, options?.headers, data);

		const response = await ctx.put(url, {
			data,
			headers: options?.headers,
			timeout: options?.timeout,
		});

		const result = await this.parseResponse<T>(response);
		this.logResponse('PUT', url, result.status, result.body);

		return result;
	}

	/**
	 * PATCH request
	 */
	async patch<T = unknown>(
		endpoint: string,
		data?: unknown,
		options?: RequestOptions
	): Promise<APIResponseResult<T>> {
		const ctx = await this.getContext();
		const url = this.buildUrl(endpoint, options?.params);

		this.logRequest('PATCH', url, options?.headers, data);

		const response = await ctx.patch(url, {
			data,
			headers: options?.headers,
			timeout: options?.timeout,
		});

		const result = await this.parseResponse<T>(response);
		this.logResponse('PATCH', url, result.status, result.body);

		return result;
	}

	/**
	 * DELETE request
	 */
	async delete<T = unknown>(
		endpoint: string,
		data?: unknown,
		options?: RequestOptions
	): Promise<APIResponseResult<T>> {
		const ctx = await this.getContext();
		const url = this.buildUrl(endpoint, options?.params);

		this.logRequest('DELETE', url, options?.headers, data);

		const response = await ctx.delete(url, {
			data,
			headers: options?.headers,
			timeout: options?.timeout,
		});

		const result = await this.parseResponse<T>(response);
		this.logResponse('DELETE', url, result.status, result.body);

		return result;
	}
}

export default BaseAPIClient;
`;

/**
 * Copy BaseAPIClient to the specified output directory
 */
export async function copyBaseClient(outputDir: string): Promise<string> {
	const targetPath = path.join(outputDir, 'BaseAPIClient.ts');

	// Ensure directory exists
	await fs.promises.mkdir(outputDir, { recursive: true });

	// Write the file
	await fs.promises.writeFile(targetPath, BASE_API_CLIENT_CONTENT, 'utf-8');

	logger.info(`BaseAPIClient copied to: ${targetPath}`);

	return targetPath;
}
